# slice_t :: struct(u: type) {
#     count := 0;
#     data := (&u).{};
# };

# slice :: !(arr: &[!n]!u, start := 0, end := n) -> slice_t(u) {
#     assert(start >= 0 and end <= n);
#     return .{
#         count = end-start,
#         data = offsetptr(arr as &void as &u, start),
#     };
# };

# print_ :: (args: slice_t(any_t)) -> void {
#     @icall "printint", args.count as int;
# };

# print :: (args: [!n]any_t) -> void {
#     print_(slice(&args));
# };

# main :: () -> void {
#     print([3]any_t.{1, 2, "something"});
# };

add :: !(a: sint, b: sint) -> sint {
    return a + b;
};

main :: () -> void {
    x := add(5, 6) as int;
    @icall "printint", x;
};