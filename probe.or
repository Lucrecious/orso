assert :: (test := false, message := "") {
    @icall "assert", test, message;
};

slice_t :: struct(u: type) {
    data := (&u).{};
    count := 0;
};

slice :: !(arr: &[!n]!u, start := 0, end := n) -> slice_t(u) {
    assert(start >= 0 and end <= n and end >= start, "slice out of range");
    s := slice_t(u).{};
    s.data = arr as &void as &u;
    s.data = offsetptr(s.data, start);
    s.count = end-start;
    return s;
};

slice_at :: (s: &slice_t(!u), index: sint) -> &u {
    assert(index < s.count);
    item := offsetptr(s.data, index);
    return item;
};

main :: () {
    x := 10;
    arr1 := slice(&&[5]sint.{1, 2, 3, 4, 5},,x);
    arr1;

    # x := *slice_at(&arr, 4);
    # @icall "printint", x as int;

    # for i := 0; i < arr.count; ++i {
    #     @icall "printint", *da.at(&arr, i) as int;
    # };
};

# main :: () {
#     arr := [4]sint.{1, 2, 3, 4};

#     s := slice(&arr);

#     x := s[2]

#     (@load "io.or").println(if x == 3 then "yes" else "no");
# };