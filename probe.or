assert :: (test := false, message := "") {
    @icall "assert", test, message;
};

slice_t :: struct(u: type) {
    data := (&u).{};
    count := 0;
};

main :: () {
    z := 10;
    add :: !(a: !u, b: u) -> u {
        return a + b + ^z;
    };

    x := 11;
    y := add(x, 8);

    @icall "printint", y as int;

    # add(5.4, 3.0);
    # @icall "printint", y as int;
};


# slice :: !(arr: &[!n]!u, start := 0, end := n) -> slice_t(u) {
#     assert(start >= 0 and end <= n and end >= start);
#     s := slice_t.{};
#     s.data = arr as &void as &u;
#     s.data = offsetptr(s.data, start);
#     s.count = end-start;
#     return s;
# };

# slice_at :: @subscript (s: slice_t(!u), index: sint) -> &u {
#     assert(index < s.count);
#     item := offsetptr(s.data, index);
#     return item;
# };

# main :: () {
#     arr := [4]sint.{1, 2, 3, 4};

#     s := slice(&arr);

#     x := s[2]

#     (@load "io.or").println(if x == 3 then "yes" else "no");
# };