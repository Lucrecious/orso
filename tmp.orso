array :: struct(T: type) {
    items: []T;
    capacity: i32;
    count: i32;
};

push :: (#foldable T: type, arr: array(T), item: T) -> void {
    if arr.count <= arr.capacity {
        arr.capacity = if arr.capacity <= 0 then 8 else arr.capacity * 2;
        new_items := new T.[arr.capacity];

        for i in count do new_items[i] = arr.items[i];
        free arr.items;
        arr.items = new_items;
    };

    arr.items[arr.count] = item;
    arr.count += 1;
};

push :: (arr: array($T), item: T) -> void {
    if arr.count < arr.capacity {
        arr.capacity = if arr.capacity <= 0 then 8 else arr.capacity * 2;
        new_items = alloc([arr.capacity]T);
        for i in count do new_items[i] = arr.items[i];
        free arr.items;
        arr.items = new_items;
    };

    arr.items[arr.count] = item;
    arr.count += 1;
};

numbers := new array(i32);

// using foldable parameter directive
push(i32, numbers, 1);
push(i32, numbers, 2);

// or using polymorphic type
push(numbers, 1);
push(numbers, 2);

point :: struct() {
    x := 0;
    y := 0;
};

p1 := point();
p2 := point() { x: 420, y: 69 };
p3 := point { x: 1, y: 2 };

numbers := array(i32);

print p1;
print p2;

// later i want to be able to overload types and regular variables. so this is possible `point: point = point()`

anon_point:  : struct {
    x := 0;
    y := 0;
};

