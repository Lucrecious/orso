## empty
foo :: () -> void {
};

print_expr foo;
# ---
foo (() -> void) => <foo :: () -> void>
# ---

## stack-arg
foo :: (arg: i32) -> void {
};

print_expr foo;
# ---
foo ((i32) -> void) => <foo :: (i32) -> void>
# ---

## stack-args
foo :: (arg1: i32, arg2: bool, arg3: void) -> void {
};

print_expr foo;
# ---
foo ((i32,bool,void) -> void) => <foo :: (i32, bool, void) -> void>
# ---

## stack-return
foo :: () -> i32 {
    return 42;
};

print_expr foo;
print foo();
# ---
foo (() -> i32) => <foo :: () -> i32>
42
# ---

## object-arg
foo :: (arg: string) {
};

print_expr foo;
# ---
foo ((string) -> void) => <foo :: (string) -> void>
# ---

## object-args
foo :: (arg1: string, arg2: symbol, arg3: string) {
};

print_expr foo;
# ---
foo ((string,symbol,string) -> void) => <foo :: (string, symbol, string) -> void>
# ---


## object-return
foo :: () -> string {
    return "hello world";
};

print_expr foo;
print foo();
# ---
foo (() -> string) => <foo :: () -> string>
hello world
# ---


## args
printn :: (n: i32, text: string) -> void {
    while n > 0 {
        print text;
        n = n - 1;
    };
};

print_expr printn;
printn(3, "foo");
# ---
printn ((i32,string) -> void) => <printn :: (i32, string) -> void>
foo
foo
foo
# ---


## args-return
concatn :: (n: i32, text: string) -> string {
    textn := "";
    return while n > 0 {
        n = n - 1;
        textn = textn + text;
    } else {
        textn;
    };
};

print_expr concatn;
print concatn(3, "foo");
# ---
concatn ((i32,string) -> string) => <concatn :: (i32, string) -> string>
foofoofoo
# ---

## fib
fib :: (n: i32) -> i32 {
    return if n <= 1 {
        n;
    } else {
        fib(n - 1) + fib(n - 2);
    };
};

print fib(10);
# ---
55
# ---

## local fib
{
    fib :: (n: i32) -> i32 {
        return if n <= 1 {
            n;
        } else {
            fib(n - 1) + fib(n - 2);
        };
    };

    print fib(10);
};
# ---
55
# ---

## call constand folded narrowed union
foo::() -> i32 {
    return 1;
};

bar := foo or null;

print bar();
# ---
1
# ---

## call nonfunction
bar := 1;

print bar();
# ---
compile error, 2: Cannot call non-function type.
# ---


## call narrowed union
foo::() -> i32 {
    return 1;
};

bar := foo or null;
bar = foo;

print bar();
# ---
1
# ---

## union parameters
foo :: (a: string|void) -> void {
    print a;
};

foo("hello world");
foo(null);
# ---
hello world
null
# ---

## binded function name despite not immediately after constant declaration
foo :: null or () -> void { };
print foo;
# ---
<foo :: () -> void>
# ---

## no binded function because assigning to mutable
foo := () { };
print foo;
# ---
<<anonymous> :: () -> void>
# ---

## still able to call after or set
foo := null or () -> i32 { return 42; };
print foo;
print foo();
# ---
<<anonymous> :: () -> i32>
42
# ---

## groups surrounding function definition
foo :: null or ((( () -> void {} )));
print foo;
# ---
<foo :: () -> void>
# ---

## filled in if and else
foo :: (n: i32) -> i32 {
    if n == 10 {
        // return within multiple blocks tests analyzer
        //   for hardcoded expression type checks
        { { return 1; }; };
    } else {
        { { return 2; }; };
    };
};
print foo;
# ---
<foo :: (i32) -> i32>
# ---

## deep return is okay
foo :: () -> i32 {
    {
        {
            return 42;
        };
    };
};
print foo;
# ---
<foo :: () -> i32>
# ---

## returning only within ifs is an error
foo :: (n: i32) -> i32 {
    if n == 1 {
        return 1;
    } else if n == 2 {
        { return 2; };
    } else if n == 3 or n == 4 {
        if n == 3 {
            { return 3; };
        } else {
            { return 4; };
        };
    };
};
print foo;
# ---
compile error, 1: function 'foo' does not return on all branches
# ---

## returning outside and inside if works
foo :: (n: i32) -> i32 {
    if n == 1 {
        return 1;
    } else if n == 2 {
        return 2;
    };

    { return 3; };
};
print foo;
# ---
<foo :: (i32) -> i32>
# ---

## returning on all branches is okay (more scoping for testing)
foo :: (n: i32) -> i32 {
    if n == 1 {
        return 1;
    } else if n == 2 {
        { return 2; };
    } else if n == 3 or n == 4 {
        if n == 3 {
            { return 3; };
        } else {
            { return 4; };
        };
    } else {
        if n > 0 {
            { return n; };
        } else {
            { return -n; };
        };
    };
};
print foo;
# ---
<foo :: (i32) -> i32>
# ---

## cannot return within a declaration (gaurenteed)
foo :: () -> void {
    x := { return; };
};
print foo;
# ---
compile error, 2: cannot return within an expression being set to a declaration
# ---

## cannot return within a declaration (not gaurenteed)
foo :: (n: bool) -> void {
    x := if n { return; };
};
print foo;
# ---
compile error 2: cannot return within an expression being set to a declaration
# ---

