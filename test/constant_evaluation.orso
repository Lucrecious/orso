## ordered assign - TODO: Redo syntax for tests to make them clearer
A :: 10;
B :: A;

print B;
# ---
10
# ---

## unordered assign
A :: B;
B :: 10;

print A;
# ---
10
# ---

## simple recursive dependency
A :: B;
B :: A;

print A;
# ---
Cannot resolve A since it requires recursive definition A -> B -> A
# ---


## skip non-constant declarations in blocks
A :: 10;

{
    A := 5;
    {
        B :: A;
        print B;
    };
};
# ---
10
# ---


## error for trying to set a constant by a mutable entity
A := 10;

{
    A := 5;
    {
        B :: A;
        print B;
    };
};
# ---
Cannot resolve B. A constant A is not declared in the scope or higher scope.
# ---


## Access local mutables within function
{
    foo :: () {
        A := 5;
        {
            B := A;
            print B;
        };
    };

    foo();
};
# ---
5
# ---


## Cannot access local mutables outside function
{
    A := 5; // TODO: Fix issue where errors are not thrown because functions are not compiled because they are not used
    foo :: () {
        {
            B := A;
            print B;
        };
    };
};
# ---
Error undeclared entity A. 
# ---


## Access global mutables outside function
A := 5;

{
    foo :: () {
        {
            B := A;
            print B;
        };
    };
};
# ---
5
# ---


## Cannot set inner constant through global mutable entity
A := 5;

{
    foo :: () {
        {
            B :: A;
            print B;
        };
    };
};
# ---
Cannot use global mutable A to resolve local constant B.
# ---


## global mutables must be ordered
x := y;
y := 10;

print x;
# ---
y is not defined.
# ---


## local mutables must be ordered
{
    x := y;
    y := 10;

    print x;
};
# ---
y is not defined.
# ---


# typedefs are just regular declarations
int :: i32;
x: int = 10;
print x;
# ---
10
# ---


# function calls are not evaluated at constant time
foo :: () -> i32 { return 42; }
x :: foo();
y :: 42; 
print x == y;
# ---
compile error 1, expression is not constant
# ---


# blocks expressions cannot be evaluated at constant time
foo :: {
    x := 5;
    y := 2;
    x * y;
};
print foo;
# ---
compile error 1, expression cannot be evaluated at constant time
# ---


# 