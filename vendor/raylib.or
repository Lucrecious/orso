vec2_t :: struct {
    x: f32;
    y: f32;
};

color_t :: struct {
    r := 0u8;
    g := 0u8;
    b := 0u8;
    a := 0u8;
};

audio_stream_t :: struct {
    buffer := (&void).{};
    processor := (&void).{};

    sample_rate := uint.{};
    sample_size := uint.{};
    channels := uint.{};
};

sound_t :: struct {
    stream := audio_stream_t.{};
    frame_count := uint.{};
};

white :: color_t.{255, 255, 255, 255};
raywhite :: color_t.{245, 245, 245, 255};
black :: color_t.{0, 0, 0, 255};
red :: color_t.{255, 0, 0, 255};
green :: color_t.{0, 255, 0, 255};
blue :: color_t.{0, 0, 255, 255};

mouse_button_left :: 0;
mouse_button_right :: 1;
mouse_button_middle :: 3;

raylib :: (@load "dynlib.or").lib_t.{
    call_conv: "cdecl",
    static_path: "./vendor/raylib/src/libraylib.a"
};

init_window :: (width: sint, height: sint, label: str8_t) -> void {
    @fficall raylib, void, "InitWindow", width as int, height as int, label.cstr;
};

close_window :: () -> void {
    @fficall raylib, void, "CloseWindow";
};

window_should_close :: () -> bool {
    return @fficall raylib, bool, "WindowShouldClose";
};

init_audio_device :: () {
    @fficall raylib, void, "InitAudioDevice";
};

load_sound :: (path: str8_t) -> sound_t {
    result := @fficall raylib, sound_t, "LoadSound", path.cstr;
    return result;
};

play_sound :: (sound: sound_t) {
    @fficall raylib, void, "PlaySound", sound;
};

begin_drawing :: () -> void {
    @fficall raylib, void, "BeginDrawing";
};

end_drawing :: () -> void {
    @fficall raylib, void, "EndDrawing";
};

draw_rectanglev :: (pos: vec2_t, size: vec2_t, color: color_t) -> void {
    @fficall raylib, void, "DrawRectangleV", pos, size, color;
};

draw_rectangle :: (pos: [2]sint, size: [2]sint, color: color_t) -> void {
    @fficall raylib, void, "DrawRectangle", pos[0] as int, pos[1] as int, size[0] as int, size[1] as int, color;
};

draw_line_v :: (a: vec2_t, b: vec2_t, color: color_t) -> void {
    @fficall raylib, void, "DrawLineV", a, b, color;
};

draw_text :: (text: str8_t, pos: [2]sint, size: sint, color: color_t) -> void {
    @fficall raylib, void, "DrawText", text.cstr, pos[0] as int, pos[1] as int, size as int, color;
};

text_format :: (text: str8_t, value: sint) -> str8_t {
    result := @fficall raylib, &char, "TextFormat", text.cstr, value as int;
    count := 0;
    while *offsetptr(result, count) != char.{} do ++count;

    return .{
        result,
        count,
    };
};

measure_text :: (text: str8_t, font_size: sint) -> sint {
    return (@fficall raylib, int, "MeasureText", text.cstr, font_size as int) as sint;
};

clear_background :: (color: color_t) -> void {
    @fficall raylib, void, "ClearBackground", color;
};

draw_pixel :: (posx: int, posy: int, color: color_t) -> void {
    @fficall raylib, void, "DrawPixel", posx, posy, color;
};

draw_fps :: (posx: int, posy: int) -> void {
    @fficall raylib, void, "DrawFPS", posx, posy;
};

set_target_fps :: (fps: int) -> void {
    @fficall raylib, void, "SetTargetFPS", fps;
};

get_frame_time :: () -> f32 {
    return @fficall raylib, f32, "GetFrameTime";
};

get_sec_elapsed :: () -> f64 {
    return @fficall raylib, f64, "GetTime";
};

is_mouse_button_pressed :: (button: sint) -> bool {
    return @fficall raylib, bool, "IsMouseButtonPressed", button as int;
};

is_mouse_button_down :: (button: sint) -> bool {
    return @fficall raylib, bool, "IsMouseButtonDown", button as int;
};

get_mouse_position :: () -> [2]sint {
    result :=  @fficall raylib, [2]f32, "GetMousePosition";
    return .{result[0] as sint, result[1] as sint};
};

check_collision_point_poly :: (point: vec2_t, points: &vec2_t, count: sint) -> bool {
    result :=  @fficall raylib, bool, "CheckCollisionPointPoly", point, points, count as int;
    return result;
};
